<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>哼唱转音乐</title>
  <style>
    :root { --bg:#0f0f12; --fg:#f2f3f5; --muted:#9aa0a6; --acc:#3e8ef7; --card:#17181c; }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font:-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",Roboto,Arial,sans-serif;}
    .wrap{max-width:720px;margin:0 auto;padding:16px 16px 80px;}
    h1{font-size:20px;margin:8px 0 12px;}
    .panel{background:var(--card);border-radius:12px;padding:14px;margin:12px 0;}
    .row{display:flex;align-items:center;gap:12px;margin:8px 0;}
    .row label{flex:0 0 120px;color:var(--muted);font-size:14px;}
    .row .val{min-width:64px;text-align:right;color:var(--fg);font-variant-numeric:tabular-nums;}
    input[type="range"]{flex:1;appearance:none;height:4px;background:#2a2c32;border-radius:99px;outline:none;}
    input[type="range"]::-webkit-slider-thumb{appearance:none;width:22px;height:22px;border-radius:50%;background:var(--acc);border:none;}
    .bigbtn{display:block;width:100%;padding:16px;border-radius:14px;border:none;background:var(--acc);color:#fff;font-weight:700;font-size:18px;}
    .bigbtn[aria-pressed="true"]{background:#d64545;}
    .note{color:var(--muted);font-size:12px;margin-top:6px;line-height:1.4;}
    ul#tracks{list-style:none;margin:0;padding:0;display:grid;gap:10px;}
    .track{display:flex;align-items:center;gap:10px;background:var(--card);padding:10px 12px;border-radius:12px}
    .play{width:40px;height:40px;border-radius:10px;border:1px solid #2d2f36;background:#1f2126;color:#fff;font-size:16px}
    .meta{flex:1;min-width:0}
    .title{font-weight:600;font-size:14px;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}
    .sub{color:var(--muted);font-size:12px}
    .actions{display:flex;gap:8px}
    .actions a,.actions button{background:#1f2126;border:1px solid #2d2f36;color:#fff;border-radius:10px;padding:8px 10px;font-size:12px;text-decoration:none}
    audio{display:none}
    .busy{opacity:.6;pointer-events:none;filter:grayscale(.1)}
  </style>
  <!-- 录音库（全局 Recorder） -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Recorderjs/0.1.0/recorder.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <div class="wrap">
    <h1>哼唱转音乐</h1>

    <div class="panel" id="ctrls">
      <div class="row">
        <label>**FFT窗宽**</label>
        <input id="win" type="range" min="0" max="4" step="1" value="2" />
        <div class="val" id="winVal">4096</div>
      </div>
      <div class="row">
        <label>**覆盖率**</label>
        <input id="ovl" type="range" min="0" max="9" step="1" value="5" />
        <div class="val" id="ovlVal">0.50</div>
      </div>
      <div class="note">说明：窗宽越大，低频分辨率更好但时域响应更慢。覆盖率指帧与帧的重叠比例。录制中禁改。</div>
    </div>

    <div class="panel">
      <button id="recBtn" class="bigbtn" aria-pressed="false">开始录制</button>
      <div class="note" id="status">就绪</div>
    </div>

    <div class="panel">
      <div style="margin-bottom:8px;font-weight:700">已生成音乐</div>
      <ul id="tracks"></ul>
      <div class="note">单击条目播放/暂停；点“导出WAV”保存处理后的音乐。</div>
    </div>
  </div>

  <script type="module">
    // 第三方库（ESM）
    import * as Tone from 'https://esm.sh/tone@14.8.49';
    import { YIN } from 'https://esm.sh/pitchfinder@2.3.2';
    import toWav from 'https://esm.sh/audiobuffer-to-wav@1.0.0';

    // ====== 基础状态 ======
    const recBtn = document.getElementById('recBtn');
    const statusEl = document.getElementById('status');
    const winSlider = document.getElementById('win');
    const ovlSlider = document.getElementById('ovl');
    const winVal = document.getElementById('winVal');
    const ovlVal = document.getElementById('ovlVal');
    const ctrls = document.getElementById('ctrls');
    const tracks = document.getElementById('tracks');

    const WINDOW_OPTIONS = [2048, 4096, 8192, 12288, 16384]; // iPhone 也能跑的范围
    const getWindowSize = () => WINDOW_OPTIONS[Number(winSlider.value)];
    const getOverlap = () => Number(ovlSlider.value)/10; // 0.0-0.9

    // UI 数值初始化
    const syncSliderLabels = () => {
      winVal.textContent = String(getWindowSize());
      ovlVal.textContent = getOverlap().toFixed(2);
    };
    syncSliderLabels();
    winSlider.addEventListener('input', syncSliderLabels);
    ovlSlider.addEventListener('input', syncSliderLabels);

    // 录制相关
    let audioCtx = null;
    let mediaStream = null;
    let sourceNode = null;
    let recorder = null;
    let isRecording = false;

    // iOS 需要用户手势恢复音频上下文
    async function ensureAudioContext() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AC({ sampleRate: 44100 });
      }
      if (audioCtx.state !== 'running') {
        await audioCtx.resume();
      }
      return audioCtx;
    }

    function setBusy(on) {
      if (on) {
        document.body.classList.add('busy');
        statusEl.textContent = '处理中…';
      } else {
        document.body.classList.remove('busy');
      }
    }

    async function startRecording() {
      await ensureAudioContext();
      // iOS/Safari 必须 HTTPS + 用户手势
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true }, video: false });
      sourceNode = audioCtx.createMediaStreamSource(mediaStream);
      // Recorder.js 需要 worker 路径
      recorder = new window.Recorder(sourceNode, {
        numChannels: 1,
        workerPath: 'https://cdnjs.cloudflare.com/ajax/libs/Recorderjs/0.1.0/recorderWorker.min.js'
      });
      recorder && recorder.record();
      isRecording = true;
      recBtn.textContent = '停止并处理';
      recBtn.setAttribute('aria-pressed','true');
      statusEl.textContent = '录制中…';
      // 禁止录制中改动参数
      winSlider.disabled = true;
      ovlSlider.disabled = true;
    }

    async function stopRecordingAndProcess() {
      if (!recorder) return;
      isRecording = false;
      recBtn.textContent = '开始录制';
      recBtn.setAttribute('aria-pressed','false');
      statusEl.textContent = '处理中…';
      setBusy(true);

      recorder.stop();

      const wavBlob = await new Promise(resolve => recorder.exportWAV(resolve, 'audio/wav'));
      recorder.clear();

      // 释放麦克风
      if (mediaStream) {
        mediaStream.getTracks().forEach(t => t.stop());
      }
      sourceNode = null;
      mediaStream = null;

      // 解码 WAV -> AudioBuffer
      const arrBuf = await wavBlob.arrayBuffer();
      const rawBuffer = await audioCtx.decodeAudioData(arrBuf);

      // 提取音高 -> 半音量化 -> 事件序列
      const windowSize = getWindowSize();
      const overlap = getOverlap();
      const events = extractQuantizedMelody(rawBuffer, windowSize, overlap);

      // 使用 Tone.js 离线渲染旋律
      const duration = events.totalDuration + 0.4; // 余量
      const rendered = await Tone.Offline(({ transport }) => {
        const synth = new Tone.Synth({
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.01, decay: 0.08, sustain: 0.2, release: 0.2 }
        }).toDestination();

        // 轻微混响美化（可注释）
        const reverb = new Tone.Reverb({ decay: 1.4, wet: 0.2 }).toDestination();
        synth.connect(reverb);

        for (const ev of events.notes) {
          // 将半音量化后的频率直接用于合成
          synth.triggerAttackRelease(ev.freq, ev.dur, ev.time);
        }
      }, duration);

      // 导出 WAV
      const wavBuffer = toWav(rendered);
      const musicBlob = new Blob([wavBuffer], { type: 'audio/wav' });

      // 加入列表
      const title = makeTitle();
      addTrackItem(title, musicBlob, {
        meta: `窗宽 ${windowSize} | 覆盖率 ${overlap.toFixed(2)} | 片段 ${events.notes.length}`
      });

      statusEl.textContent = '完成';
      winSlider.disabled = false;
      ovlSlider.disabled = false;
      setBusy(false);
    }

    recBtn.addEventListener('click', async () => {
      try {
        if (!isRecording) {
          await startRecording();
        } else {
          await stopRecordingAndProcess();
        }
      } catch (err) {
        console.error(err);
        statusEl.textContent = '失败：' + String(err && err.message || err);
        recBtn.textContent = '开始录制';
        recBtn.setAttribute('aria-pressed','false');
        winSlider.disabled = false;
        ovlSlider.disabled = false;
        setBusy(false);
      }
    });

    // ====== 核心算法：半音量化旋律提取 ======
    function extractQuantizedMelody(audioBuffer, windowSize, overlapRatio) {
      const sr = audioBuffer.sampleRate;
      const hop = Math.max(1, Math.round(windowSize * (1 - overlapRatio)));
      const ch = audioBuffer.numberOfChannels > 1
        ? mixToMono(audioBuffer)
        : audioBuffer.getChannelData(0);

      const yin = YIN({ sampleRate: sr });
      const N = ch.length;
      const rawNotes = [];
      const minFreq = 60;   // 过滤过低/噪声
      const maxFreq = 1200; // 过滤过高/噪声

      for (let i = 0; i + windowSize <= N; i += hop) {
        const frame = ch.subarray(i, i + windowSize);
        const f0 = yin(frame);
        if (!f0 || !isFinite(f0) || f0 < minFreq || f0 > maxFreq) {
          rawNotes.push(null);
        } else {
          rawNotes.push(f0);
        }
      }

      const frameDur = hop / sr;
      // 半音量化 + 简单去抖（把很短的抖动并入相邻）
      const quantized = rawNotes.map(f => f ? midiToFreq(Math.round(freqToMidi(f))) : null);

      // 合并连续相同音 / 跳过很短的片段
      const events = [];
      const MIN_DUR = 0.12; // s；过短的片段丢弃
      let t = 0;
      let i = 0;
      while (i < quantized.length) {
        const f = quantized[i];
        let len = 1;
        while (i + len < quantized.length && quantized[i + len] === f) len++;
        const dur = len * frameDur;
        if (f && dur >= MIN_DUR) {
          events.push({ time: t, dur, freq: f });
        }
        t += len * frameDur;
        i += len;
      }

      return { notes: events, totalDuration: t };
    }

    // ====== 小工具：音高/半音换算、混音 ======
    function freqToMidi(f) { return 69 + 12 * Math.log2(f / 440); }
    function midiToFreq(m) { return 440 * Math.pow(2, (m - 69) / 12); }

    function mixToMono(buffer) {
      const len = buffer.length;
      const out = new Float32Array(len);
      const chs = buffer.numberOfChannels;
      for (let c = 0; c < chs; c++) {
        const data = buffer.getChannelData(c);
        for (let i = 0; i < len; i++) out[i] += data[i] / chs;
      }
      return out;
    }

    function makeTitle() {
      const d = new Date();
      const pad = n => String(n).padStart(2,'0');
      return `处理音乐_${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}`;
    }

    // ====== 列表与播放/导出 ======
    function addTrackItem(title, blob, { meta }) {
      const url = URL.createObjectURL(blob);

      const li = document.createElement('li');
      li.className = 'track';

      const playBtn = document.createElement('button');
      playBtn.className = 'play';
      playBtn.textContent = '▶︎';

      const audio = document.createElement('audio');
      audio.src = url;
      audio.preload = 'metadata';

      const metaBox = document.createElement('div');
      metaBox.className = 'meta';
      const titleEl = document.createElement('div');
      titleEl.className = 'title';
      titleEl.textContent = title;
      const sub = document.createElement('div');
      sub.className = 'sub';
      sub.textContent = meta || '';

      metaBox.appendChild(titleEl);
      metaBox.appendChild(sub);

      const actions = document.createElement('div');
      actions.className = 'actions';
      const dl = document.createElement('a');
      dl.textContent = '导出WAV';
      dl.download = `${title}.wav`;
      dl.href = url;
      actions.appendChild(dl);

      li.appendChild(playBtn);
      li.appendChild(metaBox);
      li.appendChild(actions);
      li.appendChild(audio);
      tracks.prepend(li);

      let isPlaying = false;

      function stopAllOthers() {
        document.querySelectorAll('#tracks audio').forEach(a => {
          if (a !== audio) a.pause();
        });
        document.querySelectorAll('#tracks .play').forEach(b => {
          if (b !== playBtn) b.textContent = '▶︎';
        });
      }

      function toggle() {
        stopAllOthers();
        if (isPlaying) {
          audio.pause();
        } else {
          audio.currentTime = audio.currentTime || 0;
          audio.play();
        }
      }

      playBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggle();
      });
      li.addEventListener('click', () => toggle());

      audio.addEventListener('play', () => {
        isPlaying = true;
        playBtn.textContent = '⏸︎';
      });
      audio.addEventListener('pause', () => {
        isPlaying = false;
        playBtn.textContent = '▶︎';
      });
      audio.addEventListener('ended', () => {
        isPlaying = false;
        playBtn.textContent = '▶︎';
      });

      // 释放 URL 的简单策略：页面卸载时统一释放
      window.addEventListener('beforeunload', () => URL.revokeObjectURL(url));
    }

    // ====== 额外小修复：iOS 息屏/切后台时暂停播放 ======
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        document.querySelectorAll('#tracks audio').forEach(a => a.pause());
      }
    });

    // 防止录制冲突
    winSlider.addEventListener('touchstart', e => { if (isRecording) e.preventDefault(); }, { passive:false });
    ovlSlider.addEventListener('touchstart', e => { if (isRecording) e.preventDefault(); }, { passive:false });
  </script>
</body>
</html>
