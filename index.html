<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>哼唱→旋律（手势辅助）</title>
<style>
  :root{
    --lane-a:#1e5bff;  /* 深蓝 */
    --lane-b:#66c8ff;  /* 浅蓝 */
    --bg:#ffffff;
    --ui:#0f172a;
    --muted:#64748b;
    --brand:#0ea5e9;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ui);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
  .wrap{display:flex;flex-direction:column;height:100%;max-width:900px;margin:0 auto;}
  header{padding:10px 14px;border-bottom:1px solid #e2e8f0;display:flex;gap:8px;flex-wrap:wrap;align-items:center;position:sticky;top:0;background:rgba(255,255,255,.85);backdrop-filter:saturate(1.2) blur(6px);z-index:3}
  button,select,input{appearance:none;border:1px solid #cbd5e1;border-radius:12px;padding:10px 14px;background:#fff;color:var(--ui);font-size:15px}
  button.primary{background:var(--brand);color:#fff;border-color:var(--brand)}
  button:disabled{opacity:.5}
  .stat{font-size:13px;color:var(--muted);margin-left:auto}
  #lanes{flex:1;touch-action:none;position:relative;overflow:hidden}
  .lane{
    position:relative;height:14.2857%; user-select:none;
  }
  .lane:nth-child(odd){background:var(--lane-a)}
  .lane:nth-child(even){background:var(--lane-b)}
  /* 修复点：用 overlay 叠加“变浅”，避免 Safari 对 filter 的刷新问题 */
  .lane::after{
    content:""; position:absolute; inset:0; background:rgba(255,255,255,0);
    transition:background .06s ease;
  }
  .lane.active::after{ background:rgba(255,255,255,0.22); }
  .gutter{position:absolute;inset:auto 0 0 0;height:0}
  footer{border-top:1px solid #e2e8f0;padding:8px 14px;font-size:13px;color:var(--muted)}
  .chips{display:flex;gap:6px;flex-wrap:wrap;margin-left:8px}
  .chip{font-size:12px;border:1px dashed #cbd5e1;border-radius:999px;padding:4px 8px}
  .list{padding:8px 14px;font-size:13px;max-height:28vh;overflow:auto;border-top:1px solid #e2e8f0}
  .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <button id="btnInit" class="primary">启用麦克风 / 开始录制</button>
    <button id="btnStop" disabled>停止</button>
    <button id="btnPlay" disabled>播放旋律</button>
    <button id="btnExport" disabled>导出 MIDI</button>
    <label class="chips"><span class="chip">A4=440</span>
      <span class="chip">Semitone quantize</span>
      <span id="vibChip" class="chip">Vibrate: auto</span>
    </label>
    <div class="stat">
      采样<span id="sr">-</span>Hz · 帧<span id="buf">-</span> · 片段<span id="cnt">0</span>
    </div>
  </header>

  <div id="lanes" aria-label="gesture lanes">
    <div class="lane" data-i="0"></div>
    <div class="lane" data-i="1"></div>
    <div class="lane" data-i="2"></div>
    <div class="lane" data-i="3"></div>
    <div class="lane" data-i="4"></div>
    <div class="lane" data-i="5"></div>
    <div class="lane" data-i="6"></div>
    <div class="gutter"></div>
  </div>

  <div class="list mono" id="noteList" hidden></div>
  <footer>提示：按住或划入色块表示**起音/换音**，抬手或划出表示**停音**；色块只作提示，不对应具体音高。</footer>
</div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));
  const clamp = (x,min,max)=>Math.max(min,Math.min(max,x));
  const midi2freq = m => 440 * Math.pow(2,(m-69)/12);
  const freq2midi = f => 69 + 12 * Math.log2(f/440);
  const cents = (f1,f2)=>1200*Math.log2(f1/f2);

  let ctx, micStream, procNode, analyser;
  let sampleRate = 48000;
  let frameSize = 2048, hop = 1024;
  let isRecording = false;
  let t0Ctx = 0;
  let laneActive = null;

  const pitchBuf = [];           // {t,f0,amp}
  const hintEvents = [];         // {t,type}
  const notes = [];              // {midi,start,dur}

  const MIN_F = 80, MAX_F = 1000;
  const ENERGY_TH = 0.004;       // 略放宽，提升拾音稳定度
  const MIN_NOTE_MS = 80;
  const ALIGN_WIN = 0.18;
  const RELEASE_GAP = 0.12;

  const vibrateOK = 'vibrate' in navigator;
  $('#vibChip').textContent = `Vibrate: ${vibrateOK ? 'on' : 'off'}`;
  const vib = ms => { if (vibrateOK) try { navigator.vibrate(ms); } catch(e){} };

  const lanes = $('#lanes');
  const laneDivs = $$('.lane');

  function laneFromTouch(clientY){
    const rect = lanes.getBoundingClientRect();
    if (clientY < rect.top || clientY > rect.bottom) return -1;
    const y = clientY - rect.top;
    const h = rect.height;
    const idx = Math.floor(y / (h / laneDivs.length));
    return clamp(idx,0,laneDivs.length-1);
  }
  function setActiveLane(i){
    if (laneActive === i) return;
    if (laneActive!=null && laneActive>=0) laneDivs[laneActive].classList.remove('active');
    laneActive = i;
    if (laneActive!=null && laneActive>=0) laneDivs[laneActive].classList.add('active');
  }

  // ---- 关键修复：手势发生时立即触发切分 ----
  function markHint(type){
    if (!isRecording || !ctx) return;
    const t = ctx.currentTime;
    hintEvents.push({t, type});
    ensureBoundary(t);           // ★ 新增：把手势作为强边界
    if (type==='start' || type==='change' || type==='stop') vib(8);
  }

  lanes.addEventListener('touchstart', (e)=>{
    e.preventDefault();
    const i = laneFromTouch(e.touches[0].clientY);
    if (i>=0){ setActiveLane(i); markHint('start'); }
  }, {passive:false});
  lanes.addEventListener('touchmove', (e)=>{
    e.preventDefault();
    const i = laneFromTouch(e.touches[0].clientY);
    if (i>=0 && i!==laneActive){ setActiveLane(i); markHint('change'); }
    if (i<0 && laneActive!=null){ setActiveLane(-1); markHint('stop'); }
  }, {passive:false});
  lanes.addEventListener('touchend', (e)=>{
    e.preventDefault();
    setActiveLane(-1); markHint('stop');
  }, {passive:false});

  lanes.addEventListener('mousedown', (e)=>{
    const i = laneFromTouch(e.clientY);
    if (i>=0){ setActiveLane(i); markHint('start'); }
  });
  lanes.addEventListener('mousemove', (e)=>{
    if (e.buttons!==1) return;
    const i = laneFromTouch(e.clientY);
    if (i>=0 && i!==laneActive){ setActiveLane(i); markHint('change'); }
    if (i<0 && laneActive!=null){ setActiveLane(-1); markHint('stop'); }
  });
  window.addEventListener('mouseup', ()=>{
    if (laneActive!=null){ setActiveLane(-1); markHint('stop'); }
  });

  async function startRecording(){
    if (!ctx){
      ctx = new (window.AudioContext || window.webkitAudioContext)();
      sampleRate = ctx.sampleRate;
      $('#sr').textContent = sampleRate|0;
    }
    await ctx.resume();

    micStream = await navigator.mediaDevices.getUserMedia({audio:{
      echoCancellation:false, noiseSuppression:false, autoGainControl:false
    }});

    const src = ctx.createMediaStreamSource(micStream);

    const bufSize = frameSize;
    $('#buf').textContent = bufSize;
    procNode = (ctx.createScriptProcessor||ctx.createJavaScriptNode).call(ctx, bufSize, 1, 1);
    procNode.onaudioprocess = e=>{
      const input = e.inputBuffer.getChannelData(0);
      const tCtx = ctx.currentTime;
      processFrame(input, tCtx);
    };

    analyser = ctx.createAnalyser(); analyser.fftSize = 1024;

    src.connect(procNode);
    src.connect(analyser);
    procNode.connect(ctx.destination);

    isRecording = true;
    t0Ctx = ctx.currentTime;
    pitchBuf.length = 0; hintEvents.length = 0; notes.length = 0;
    lastBoundary = null; lastAutoMid = null; lastAutoTime = null;
    $('#cnt').textContent = '0';
    $('#noteList').hidden = true;

    $('#btnInit').disabled = true;
    $('#btnStop').disabled = false;
    $('#btnPlay').disabled = true;
    $('#btnExport').disabled = true;
  }

  function stopRecording(){
    isRecording = false;
    try{ procNode.disconnect(); }catch(e){}
    try{ analyser.disconnect(); }catch(e){}
    try{ micStream.getTracks().forEach(t=>t.stop()); }catch(e){}

    finalizeAll();
    renderNoteList();

    $('#btnInit').disabled = false;
    $('#btnStop').disabled = true;
    $('#btnPlay').disabled = notes.length===0;
    $('#btnExport').disabled = notes.length===0;
  }

  // --- 基频估计：简化 ACF ---
  function estimateF0ACF(frame, sr){
    let sum = 0; for (let i=0;i<frame.length;i++){ const s=frame[i]; sum += s*s; }
    const energy = sum / frame.length;
    if (energy < ENERGY_TH) return null;

    const minLag = Math.floor(sr / MAX_F);
    const maxLag = Math.floor(sr / MIN_F);
    let bestLag = -1, bestCorr = 0;

    for (let lag=minLag; lag<=maxLag; lag++){
      let corr = 0;
      for (let i=0; i<frame.length-lag; i++){
        corr += frame[i]*frame[i+lag];
      }
      corr /= (frame.length-lag);
      if (corr > bestCorr){ bestCorr = corr; bestLag = lag; }
    }
    if (bestLag < 0) return null;
    const f0 = sr / bestLag;
    return {f0, amp: Math.sqrt(energy)};
  }

  function processFrame(input, tCtx){
    const est = estimateF0ACF(input, sampleRate);
    if (est){ pitchBuf.push({t: tCtx, f0: est.f0, amp: est.amp}); }
    else{ pitchBuf.push({t: tCtx, f0: 0, amp: 0}); }
    autoBoundary();
  }

  function sliceByTime(tStart, tEnd){
    const seg = pitchBuf.filter(p => p.t>=tStart && p.t<tEnd && p.f0>0);
    if (seg.length===0) return null;
    const fs = seg.map(p=>p.f0).sort((a,b)=>a-b);
    const fMed = fs[fs.length>>1];
    const midi = Math.round(freq2midi(fMed));
    const freqQ = midi2freq(midi);
    const ok = seg.filter(p=>Math.abs(cents(p.f0, freqQ))<100).length / seg.length > 0.5;
    if (!ok) return null;
    return {midi, freq:freqQ};
  }

  let lastBoundary = null;
  function ensureBoundary(t){
    if (!isRecording) return;
    if (lastBoundary==null) lastBoundary = t0Ctx;
    if ((t - lastBoundary) * 1000 < MIN_NOTE_MS){ lastBoundary = t; return; }
    const seg = sliceByTime(lastBoundary, t);
    if (seg){
      const start = lastBoundary;
      const dur = t - lastBoundary;
      notes.push({midi:seg.midi, start, dur});
      $('#cnt').textContent = String(notes.length);
    }
    lastBoundary = t;
  }

  let lastAutoMid = null, lastAutoTime = null;
  function autoBoundary(){
    if (pitchBuf.length<3) return;
    const p = pitchBuf[pitchBuf.length-1];
    if (p.f0<=0){
      if (lastAutoTime && (p.t - lastAutoTime)>RELEASE_GAP && isRecording){
        ensureBoundary(p.t);
        lastAutoMid = null; lastAutoTime = null;
      }
      return;
    }
    const m = freq2midi(p.f0);
    if (lastAutoMid==null){ lastAutoMid=m; lastAutoTime=p.t; return; }
    if (Math.abs(m - lastAutoMid) >= 0.8){
      ensureBoundary(p.t);
      lastAutoMid = m; lastAutoTime = p.t;
    }
  }

  function finalizeAll(){
    const tEnd = (pitchBuf.length? pitchBuf[pitchBuf.length-1].t : (ctx?ctx.currentTime:0));
    if (lastBoundary==null) lastBoundary = t0Ctx;
    if ((tEnd - lastBoundary)*1000 >= MIN_NOTE_MS){
      const seg = sliceByTime(lastBoundary, tEnd);
      if (seg){ notes.push({midi:seg.midi, start:lastBoundary, dur:tEnd-lastBoundary}); }
    }
    const t0 = notes.length? notes[0].start : 0;
    notes.forEach(n=>{ n.start -= t0; });
    $('#cnt').textContent = String(notes.length);
  }

  function playNotes(bpm=120){
    if (!notes.length) return;
    if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
    const tStart = ctx.currentTime + 0.05;
    const A=0.0005, D=0.01, S=0.15, R=0.08;
    const master = ctx.createGain(); master.gain.value = 0.6; master.connect(ctx.destination);
    notes.forEach(n=>{
      const o=ctx.createOscillator(); o.type='sine'; o.frequency.value = midi2freq(n.midi);
      const g=ctx.createGain(); g.gain.value=0; o.connect(g); g.connect(master);
      const t = tStart + n.start; const d = Math.max(0.03, n.dur);
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(1.0, t+A);
      g.gain.linearRampToValueAtTime(S, t+A+D);
      g.gain.setValueAtTime(S, t+d-R);
      g.gain.linearRampToValueAtTime(0, t+d);
      o.start(t); o.stop(t+d+0.02);
    });
  }

  function exportMIDI(filename='humming.mid'){
    if (!notes.length) return;
    const PPQ=480, BPM=120;
    const microPerQN = Math.round(60000000/BPM);
    const events = [];
    notes.forEach(n=>{
      const tickOn = Math.round(n.start * (PPQ*BPM/60));
      const tickOff = Math.round((n.start+n.dur) * (PPQ*BPM/60));
      const key = clamp(n.midi, 0, 127)|0;
      events.push({tick:tickOn, type:0x90, key, vel:96});
      events.push({tick:tickOff, type:0x80, key, vel:0});
    });
    events.sort((a,b)=>a.tick-b.tick);
    function vlq(n){ const bytes=[]; let buffer = n & 0x7F;
      while((n >>= 7)){ buffer <<= 8; buffer |= ((n & 0x7F) | 0x80); }
      while(true){ bytes.push(buffer & 0xFF); if (buffer & 0x80) buffer >>= 8; else break; }
      return bytes; }
    function push(arr,...xs){ xs.forEach(x=>arr.push(x&0xFF)); }

    const header = [];
    push(header, 0x4d,0x54,0x68,0x64, 0x00,0x00,0x00,0x06, 0x00,0x00, 0x00,0x01,  (PPQ>>8)&0xFF, PPQ&0xFF);
    let track = [];
    track.push(0x00, 0xff, 0x51, 0x03, (microPerQN>>16)&0xFF, (microPerQN>>8)&0xFF, microPerQN&0xFF);
    track.push(0x00, 0xC0, 0x00);
    let prevTick = 0;
    events.forEach(ev=>{
      const dt = ev.tick - prevTick; prevTick = ev.tick;
      track.push(...vlq(dt), ev.type, ev.key, ev.vel);
    });
    track.push(0x00, 0xff, 0x2f, 0x00);
    const len = track.length;
    const trackHeader = [0x4d,0x54,0x72,0x6b, (len>>>24)&0xFF,(len>>>16)&0xFF,(len>>>8)&0xFF,len&0xFF];
    const bytes = new Uint8Array(header.length + trackHeader.length + len);
    bytes.set(header,0); bytes.set(trackHeader,header.length); bytes.set(track,header.length+trackHeader.length);
    const blob = new Blob([bytes], {type:'audio/midi'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click();
    URL.revokeObjectURL(a.href);
  }

  function renderNoteList(){
    const box = $('#noteList');
    if (!notes.length){ box.hidden=true; return; }
    const rows = notes.map((n,i)=> {
      const hz = midi2freq(n.midi).toFixed(2);
      const t = (n.start).toFixed(3);
      const d = (n.dur).toFixed(3);
      return `${String(i+1).padStart(3,' ')}  MIDI:${n.midi.toString().padStart(3,' ')}  Hz:${hz.padStart(7,' ')}  t:${t.padStart(6,' ')}s  d:${d.padStart(6,' ')}s`;
    }).join('\n');
    box.textContent = rows;
    box.hidden = false;
  }

  $('#btnInit').addEventListener('click', startRecording);
  $('#btnStop').addEventListener('click', stopRecording);
  $('#btnPlay').addEventListener('click', ()=>playNotes(120));
  $('#btnExport').addEventListener('click', exportMIDI);
})();
</script>
</body>
</html>
