<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>哼唱→旋律（手势辅助）</title>
<style>
  :root{
    --lane-a:#1e5bff;   /* 深蓝 */
    --lane-b:#66c8ff;   /* 浅蓝 */
    --bg:#ffffff;
    --ui:#0f172a;
    --muted:#64748b;
    --brand:#0ea5e9;
    --danger:#ef4444;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ui);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
  .wrap{display:flex;flex-direction:column;height:100%;max-width:900px;margin:0 auto;}
  header{padding:10px 14px;border-bottom:1px solid #e2e8f0;display:flex;gap:8px;flex-wrap:wrap;align-items:center;position:sticky;top:0;background:rgba(255,255,255,.85);backdrop-filter:saturate(1.2) blur(6px);z-index:3}
  button{appearance:none;border:1px solid #cbd5e1;border-radius:12px;padding:10px 14px;background:#fff;color:var(--ui);font-size:15px}
  button.primary{background:var(--brand);color:#fff;border-color:var(--brand)}
  button.recOn{background:var(--danger);border-color:var(--danger);color:#fff}
  button:disabled{opacity:.5}
  .stat{font-size:13px;color:var(--muted);margin-left:auto}
  #lanes{flex:1;touch-action:none;position:relative;overflow:hidden}
  .lane{position:relative;height:14.2857%; user-select:none;}
  .lane:nth-child(odd){background:var(--lane-a)}
  .lane:nth-child(even){background:var(--lane-b)}
  /* 稳定变浅：叠加白色半透明层，避免 Safari filter 重绘问题 */
  .lane::after{content:""; position:absolute; inset:0; background:rgba(255,255,255,0); transition:background .06s ease;}
  .lane.active::after{ background:rgba(255,255,255,0.22); }
  .gutter{position:absolute;inset:auto 0 0 0;height:0}
  footer{border-top:1px solid #e2e8f0;padding:8px 14px;font-size:13px;color:var(--muted)}
  .chips{display:flex;gap:6px;flex-wrap:wrap;margin-left:8px}
  .chip{font-size:12px;border:1px dashed #cbd5e1;border-radius:999px;padding:4px 8px}
  .list{padding:8px 14px;font-size:13px;max-height:28vh;overflow:auto;border-top:1px solid #e2e8f0}
  .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <button id="btnRec" class="primary">启用麦克风 / 开始录制</button>
    <button id="btnPlay" disabled>播放旋律</button>
    <button id="btnExport" disabled>导出 MIDI</button>
    <label class="chips"><span class="chip">A4=440</span>
      <span class="chip">Semitone quantize</span>
      <span id="vibChip" class="chip">Vibrate: auto</span>
    </label>
    <div class="stat">
      采样<span id="sr">-</span>Hz · 片段<span id="cnt">0</span>
    </div>
  </header>

  <div id="lanes" aria-label="gesture lanes">
    <div class="lane" data-i="0"></div>
    <div class="lane" data-i="1"></div>
    <div class="lane" data-i="2"></div>
    <div class="lane" data-i="3"></div>
    <div class="lane" data-i="4"></div>
    <div class="lane" data-i="5"></div>
    <div class="lane" data-i="6"></div>
    <div class="gutter"></div>
  </div>

  <div class="list mono" id="noteList" hidden></div>
  <footer>提示：按住或划入色块表示起音或换音，抬手或划出表示停音。色块仅提示事件，不对应具体音高。</footer>
</div>

<script>
(() => {
  // ===== 工具 =====
  const $ = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));
  const clamp = (x,min,max)=>Math.max(min,Math.min(max,x));
  const midi2freq = m => 440 * Math.pow(2,(m-69)/12);
  const freq2midi = f => 69 + 12 * Math.log2(f/440);
  const cents = (f1,f2)=>1200*Math.log2(f1/f2);
  const median = arr => { const a=[...arr].sort((x,y)=>x-y); const k=a.length>>1; return a.length? a[k] : 0; };

  // ===== 全局音频上下文与主增益（防止被 GC） =====
  let ctx = null, master = null, audioUnlocked = false;
  async function unlockAudioOnce(){
    if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
    if (ctx.state !== 'running') await ctx.resume();
    if (!audioUnlocked){
      // iOS 解锁：播放一次极短静音
      const buf = ctx.createBuffer(1, 1, ctx.sampleRate);
      const src = ctx.createBufferSource(); src.buffer = buf; src.connect(ctx.destination); src.start(0);
      audioUnlocked = true;
    }
    if (!master){
      master = ctx.createGain(); master.gain.value = 0.6; master.connect(ctx.destination);
    }
  }

  // ===== 运行状态 =====
  let micStream = null, analyser = null, zeroGain = null, rafId = null;
  let sampleRate = 48000;
  let isRecording = false;
  let t0Ctx = 0, tEndCtx = 0;
  let laneActive = null;

  const pitchBuf = [];     // {t,f0,amp}
  const notes = [];        // {midi,start,dur}
  let framesSeen = 0, nonZeroF0 = 0;

  // 参数
  const MIN_F = 80, MAX_F = 1000;
  const ENERGY_TH = 0.0005;      // 放宽静音门限
  const MIN_NOTE_MS = 80;
  const RELEASE_GAP = 0.12;

  // 震动
  const vibrateOK = 'vibrate' in navigator;
  $('#vibChip').textContent = `Vibrate: ${vibrateOK ? 'on' : 'off'}`;
  const vib = ms => { if (vibrateOK) try{ navigator.vibrate(ms);}catch(e){} };

  // ===== 触控 UI（仅录制时生效；录制外不变色） =====
  const lanes = $('#lanes');
  const laneDivs = $$('.lane');

  function laneFromY(clientY){
    const rect = lanes.getBoundingClientRect();
    if (clientY < rect.top || clientY > rect.bottom) return -1;
    const idx = Math.floor((clientY - rect.top) / (rect.height / laneDivs.length));
    return clamp(idx,0,laneDivs.length-1);
    }
  function setActiveLane(i){
    if (laneActive === i) return;
    if (laneActive!=null && laneActive>=0) laneDivs[laneActive].classList.remove('active');
    laneActive = i;
    if (laneActive!=null && laneActive>=0) laneDivs[laneActive].classList.add('active');
  }
  function clearActiveLane(){
    if (laneActive!=null && laneActive>=0) laneDivs[laneActive].classList.remove('active');
    laneActive = null;
  }

  function onGesture(){
    if (!isRecording || !ctx) return;
    const t = ctx.currentTime;
    ensureBoundary(t);      // 手势=强边界
    vib(8);
  }

  // 仅在录制中处理触摸/鼠标
  lanes.addEventListener('touchstart', (e)=>{ if(!isRecording) return;
    e.preventDefault(); const i = laneFromY(e.touches[0].clientY);
    if (i>=0){ setActiveLane(i); onGesture(); }
  }, {passive:false});
  lanes.addEventListener('touchmove', (e)=>{ if(!isRecording) return;
    e.preventDefault(); const i = laneFromY(e.touches[0].clientY);
    if (i>=0 && i!==laneActive){ setActiveLane(i); onGesture(); }
    if (i<0 && laneActive!=null){ clearActiveLane(); onGesture(); }
  }, {passive:false});
  lanes.addEventListener('touchend', (e)=>{ if(!isRecording) return; e.preventDefault(); clearActiveLane(); onGesture(); }, {passive:false});
  lanes.addEventListener('mousedown', (e)=>{ if(!isRecording) return;
    const i = laneFromY(e.clientY); if (i>=0){ setActiveLane(i); onGesture(); }
  });
  lanes.addEventListener('mousemove', (e)=>{ if(!isRecording || e.buttons!==1) return;
    const i = laneFromY(e.clientY);
    if (i>=0 && i!==laneActive){ setActiveLane(i); onGesture(); }
    if (i<0 && laneActive!=null){ clearActiveLane(); onGesture(); }
  });
  window.addEventListener('mouseup', ()=>{ if(!isRecording) return; clearActiveLane(); onGesture(); });

  // ===== 录制开关（合并按钮）=====
  const btnRec = $('#btnRec'), btnPlay = $('#btnPlay'), btnExport = $('#btnExport');
  btnRec.addEventListener('click', async ()=>{
    if (!isRecording) await startRecording(); else stopRecording();
  });

  async function startRecording(){
    await unlockAudioOnce();                  // ★ 先解锁音频
    sampleRate = ctx.sampleRate;
    $('#sr').textContent = sampleRate|0;

    micStream = await navigator.mediaDevices.getUserMedia({audio:{
      echoCancellation:false, noiseSuppression:false, autoGainControl:false
    }});
    const src = ctx.createMediaStreamSource(micStream);

    analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;                 // 与 ACF 长度一致
    analyser.smoothingTimeConstant = 0;
    const workBuf = new Float32Array(analyser.fftSize);

    // 静音支路，保证图不断开（某些 iOS 设备否则会“睡死”）
    zeroGain = ctx.createGain(); zeroGain.gain.value = 0;
    src.connect(analyser);
    src.connect(zeroGain); zeroGain.connect(ctx.destination);

    // 状态复位
    isRecording = true;
    t0Ctx = ctx.currentTime; tEndCtx = t0Ctx;
    pitchBuf.length = 0; notes.length = 0;
    framesSeen = 0; nonZeroF0 = 0;
    lastBoundary = null; silenceSince = null;
    $('#cnt').textContent = '0';
    $('#noteList').hidden = true;

    // UI
    btnRec.textContent = '停止';
    btnRec.classList.remove('primary'); btnRec.classList.add('recOn');
    updateButtons(); // 录制中禁用播/导

    // 轮询采样（替代 ScriptProcessorNode）
    const loop = ()=>{
      analyser.getFloatTimeDomainData(workBuf);
      tEndCtx = ctx.currentTime;
      processFrame(workBuf, tEndCtx);
      rafId = requestAnimationFrame(loop);
    };
    rafId = requestAnimationFrame(loop);
  }

  function stopRecording(){
    isRecording = false;

    if (rafId){ cancelAnimationFrame(rafId); rafId=null; }
    try{ analyser.disconnect(); }catch(e){}
    try{ zeroGain.disconnect(); }catch(e){}
    try{ micStream.getTracks().forEach(t=>t.stop()); }catch(e){}
    clearActiveLane();

    finalizeAll();     // 收尾切分（含兜底）
    renderNoteList();
    updateButtons();   // 强制刷新按钮状态

    btnRec.textContent = '开始录制';
    btnRec.classList.remove('recOn'); btnRec.classList.add('primary');
  }

  function updateButtons(){
    const has = notes.length>0;
    btnPlay.disabled = !has; btnExport.disabled = !has;
    if (has){ btnPlay.removeAttribute('disabled'); btnExport.removeAttribute('disabled'); }
    else { btnPlay.setAttribute('disabled',''); btnExport.setAttribute('disabled',''); }
    // iOS Safari 个别渲染滞后，强制 reflow
    void btnPlay.offsetHeight; void btnExport.offsetHeight;
    $('#cnt').textContent = String(notes.length);
  }

  // ===== 基频估计（Hann + 自相关）=====
  function estimateF0ACF(frame, sr){
    const N = frame.length; framesSeen++;
    // 去直流 + Hann
    let mean=0; for (let i=0;i<N;i++) mean+=frame[i]; mean/=N;
    const w = Math.PI*2/(N-1);
    let energy=0; const x = new Float32Array(N);
    for (let i=0;i<N;i++){ const s=(frame[i]-mean)*(0.5-0.5*Math.cos(w*i)); x[i]=s; energy+=s*s; }
    energy/=N;
    if (energy < ENERGY_TH) return null;

    const minLag = Math.floor(sr / MAX_F);
    const maxLag = Math.floor(sr / MIN_F);
    let bestLag = -1, best = 0;
    for (let lag=minLag; lag<=maxLag; lag++){
      let c=0;
      for (let i=0; i<N-lag; i++) c += x[i]*x[i+lag];
      c/= (N-lag);
      if (c>best){ best=c; bestLag=lag; }
    }
    if (bestLag<0) return null;
    return {f0: sr/bestLag, amp: Math.sqrt(energy)};
  }

  // ===== 分段与收尾 =====
  let lastBoundary = null;
  let silenceSince = null;

  function processFrame(input, tCtx){
    const est = estimateF0ACF(input, sampleRate);
    if (est){ pitchBuf.push({t:tCtx, f0:est.f0, amp:est.amp}); nonZeroF0++; silenceSince = null; }
    else { pitchBuf.push({t:tCtx, f0:0, amp:0}); if (silenceSince==null) silenceSince = tCtx; }

    // 无手势时的自动停音（持续静音触发一次边界）
    if (silenceSince!=null && (tCtx - silenceSince) > RELEASE_GAP && isRecording){
      ensureBoundary(tCtx);
      silenceSince = null;
    }
  }

  function sliceByTime(tStart, tEnd){
    const seg = pitchBuf.filter(p => p.t>=tStart && p.t<tEnd && p.f0>0);
    if (seg.length===0) return null;
    const fMed = median(seg.map(p=>p.f0));
    const midi = Math.round(freq2midi(fMed));     // **半音量化**
    const fq = midi2freq(midi);
    // 一致性校验（±120 cents 之内占比 > 40%）
    const ok = seg.filter(p=>Math.abs(cents(p.f0, fq))<120).length / seg.length > 0.4;
    if (!ok) return null;
    return {midi, freq:fq};
  }

  // 去抖：太密的边界直接忽略，不改写 lastBoundary
  function ensureBoundary(t){
    if (!ctx) return;
    if (lastBoundary==null) lastBoundary = t0Ctx;
    if ((t - lastBoundary)*1000 < MIN_NOTE_MS) return;
    const seg = sliceByTime(lastBoundary, t);
    if (seg) notes.push({midi:seg.midi, start:lastBoundary, dur:t-lastBoundary});
    lastBoundary = t;
  }

  function finalizeAll(){
    const tEnd = pitchBuf.length ? pitchBuf[pitchBuf.length-1].t : tEndCtx;
    if (lastBoundary==null) lastBoundary = t0Ctx;
    if ((tEnd - lastBoundary)*1000 >= MIN_NOTE_MS){
      const seg = sliceByTime(lastBoundary, tEnd);
      if (seg) notes.push({midi:seg.midi, start:lastBoundary, dur:tEnd-lastBoundary});
    }
    // 若仍无音符：有非零 f0 用中位数；否则用 A4（69）
    if (!notes.length){
      let fCand = 0;
      if (nonZeroF0>0){
        fCand = median(pitchBuf.filter(p=>p.f0>0).map(p=>p.f0));
      }else{
        fCand = 440;
      }
      const midi = Math.round(freq2midi(fCand));
      const dur = Math.max(0.2, tEnd - t0Ctx);
      notes.push({midi, start:0, dur: isFinite(dur) ? dur : 0.5});
    }
    // 归一化到 0
    const t0 = notes[0].start; notes.forEach(n=>{ n.start -= t0; });
  }

  // ===== 播放（含解锁与“防过去时间”）=====
  const scheduledKeep = []; // 保留节点引用直到 stop，防 GC
  btnPlay.addEventListener('click', async ()=>{
    if (!notes.length) return;
    await unlockAudioOnce();   // 再次确保已解锁并 Running

    // 基准起点；避免把事件排在“过去”
    const base = Math.max(ctx.currentTime + 0.12, 0);
    const A=0.0005, D=0.01, S=0.15, R=0.08;

    notes.forEach(n=>{
      const o=ctx.createOscillator(); o.type='sine'; o.frequency.value = midi2freq(n.midi);
      const g=ctx.createGain(); g.gain.value=0; o.connect(g); g.connect(master);
      const startTime = Math.max(base + n.start, ctx.currentTime + 0.02);
      const d = Math.max(0.03, n.dur);

      // ADSR
      g.gain.setValueAtTime(0, startTime);
      g.gain.linearRampToValueAtTime(1.0, startTime + A);
      g.gain.linearRampToValueAtTime(S,    startTime + A + D);
      g.gain.setValueAtTime(S,             startTime + d - R);
      g.gain.linearRampToValueAtTime(0,    startTime + d);

      o.start(startTime);
      o.stop(startTime + d + 0.02);

      // 保持引用直到结束
      scheduledKeep.push(o,g);
      setTimeout(()=>{ const k=scheduledKeep.indexOf(o); if(k>=0) scheduledKeep.splice(k,1);
                       const k2=scheduledKeep.indexOf(g); if(k2>=0) scheduledKeep.splice(k2,1); },
                 Math.ceil((startTime + d + 0.05 - ctx.currentTime)*1000));
    });
  });

  // ===== 导出 MIDI =====
  btnExport.addEventListener('click', ()=>{
    if (!notes.length) return;
    const PPQ=480, BPM=120;
    const microPerQN = Math.round(60000000/BPM);

    const events = [];
    notes.forEach(n=>{
      const tickOn  = Math.round(n.start * (PPQ*BPM/60));
      const tickOff = Math.round((n.start+n.dur) * (PPQ*BPM/60));
      const key = clamp(n.midi, 0, 127)|0;
      events.push({tick:tickOn, type:0x90, key, vel:96});
      events.push({tick:tickOff, type:0x80, key, vel:0});
    });
    events.sort((a,b)=>a.tick-b.tick);

    function vlq(n){ const bytes=[]; let buffer = n & 0x7F;
      while((n >>= 7)){ buffer <<= 8; buffer |= ((n & 0x7F) | 0x80); }
      while(true){ bytes.push(buffer & 0xFF); if (buffer & 0x80) buffer >>= 8; else break; }
      return bytes; }
    function push(arr,...xs){ xs.forEach(x=>arr.push(x&0xFF)); }

    // Header
    const header = [];
    push(header, 0x4d,0x54,0x68,0x64, 0x00,0x00,0x00,0x06, 0x00,0x00, 0x00,0x01,  (PPQ>>8)&0xFF, PPQ&0xFF);

    // Track
    let track = [];
    // Tempo
    track.push(0x00, 0xff, 0x51, 0x03, (microPerQN>>16)&0xFF, (microPerQN>>8)&0xFF, microPerQN&0xFF);
    // Program Change: Acoustic Grand
    track.push(0x00, 0xC0, 0x00);

    let prevTick = 0;
    events.forEach(ev=>{
      const dt = ev.tick - prevTick; prevTick = ev.tick;
      track.push(...vlq(dt), ev.type, ev.key, ev.vel);
    });
    // End of Track
    track.push(0x00, 0xff, 0x2f, 0x00);

    const len = track.length;
    const trackHeader = [0x4d,0x54,0x72,0x6b, (len>>>24)&0xFF,(len>>>16)&0xFF,(len>>>8)&0xFF,len&0xFF];

    const bytes = new Uint8Array(header.length + trackHeader.length + len);
    bytes.set(header,0); bytes.set(trackHeader,header.length); bytes.set(track,header.length+trackHeader.length);

    // Safari 更稳的 MIME
    const blob = new Blob([bytes], {type:'application/octet-stream'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'humming.mid';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
  });

  // ===== 列表 =====
  function renderNoteList(){
    const box = $('#noteList');
    if (!notes.length){ box.hidden=true; return; }
    const rows = notes.map((n,i)=> {
      const hz = midi2freq(n.midi).toFixed(2);
      const t = (n.start).toFixed(3);
      const d = (n.dur).toFixed(3);
      return `${String(i+1).padStart(3,' ')}  MIDI:${n.midi.toString().padStart(3,' ')}  Hz:${hz.padStart(7,' ')}  t:${t.padStart(6,' ')}s  d:${d.padStart(6,' ')}s`;
    }).join('\n');
    box.textContent = rows;
    box.hidden = false;
  }
})();
</script>
</body>
</html>
